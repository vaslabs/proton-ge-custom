From 94674ac45e8a4618c00519e04b254de76aad35a2 Mon Sep 17 00:00:00 2001
From: Philip Rebohle <philip.rebohle@tu-dortmund.de>
Date: Fri, 21 May 2021 22:55:54 +0200
Subject: [PATCH] [dxvk] Skip CPU adapters if GPUs are present

Because some games try (and fail) to run on Lavapipe despite it already
being the lowest priority device in the list.
---
 src/dxvk/dxvk_device_filter.cpp | 15 ++++++++++++++-
 src/dxvk/dxvk_device_filter.h   |  3 ++-
 src/dxvk/dxvk_instance.cpp      | 23 ++++++++++++++---------
 3 files changed, 30 insertions(+), 11 deletions(-)

diff --git a/src/dxvk/dxvk_device_filter.cpp b/src/dxvk/dxvk_device_filter.cpp
index 29f40de70..02d8329ee 100644
--- a/src/dxvk/dxvk_device_filter.cpp
+++ b/src/dxvk/dxvk_device_filter.cpp
@@ -2,7 +2,8 @@
 
 namespace dxvk {
   
-  DxvkDeviceFilter::DxvkDeviceFilter() {
+  DxvkDeviceFilter::DxvkDeviceFilter(DxvkDeviceFilterFlags flags)
+  : m_flags(flags) {
     m_matchDeviceName = env::getEnvVar("DXVK_FILTER_DEVICE_NAME");
     
     if (m_matchDeviceName.size() != 0)
@@ -16,11 +17,23 @@ namespace dxvk {
   
   
   bool DxvkDeviceFilter::testAdapter(const VkPhysicalDeviceProperties& properties) const {
+    if (properties.apiVersion < VK_MAKE_VERSION(1, 1, 0)) {
+      Logger::warn(str::format("Skipping Vulkan 1.0 adapter: ", properties.deviceName));
+      return false;
+    }
+
     if (m_flags.test(DxvkDeviceFilterFlag::MatchDeviceName)) {
       if (std::string(properties.deviceName).find(m_matchDeviceName) == std::string::npos)
         return false;
     }
 
+    if (m_flags.test(DxvkDeviceFilterFlag::SkipCpuDevices)) {
+      if (properties.deviceType == VK_PHYSICAL_DEVICE_TYPE_CPU) {
+        Logger::warn(str::format("Skipping CPU adapter: ", properties.deviceName));
+        return false;
+      }
+    }
+
     return true;
   }
   
diff --git a/src/dxvk/dxvk_device_filter.h b/src/dxvk/dxvk_device_filter.h
index a0cb9d04e..7b411e6ad 100644
--- a/src/dxvk/dxvk_device_filter.h
+++ b/src/dxvk/dxvk_device_filter.h
@@ -13,6 +13,7 @@ namespace dxvk {
    */
   enum class DxvkDeviceFilterFlag {
     MatchDeviceName   = 0,
+    SkipCpuDevices    = 1,
   };
   
   using DxvkDeviceFilterFlags = Flags<DxvkDeviceFilterFlag>;
@@ -30,7 +31,7 @@ namespace dxvk {
     
   public:
     
-    DxvkDeviceFilter();
+    DxvkDeviceFilter(DxvkDeviceFilterFlags flags);
     ~DxvkDeviceFilter();
     
     /**
diff --git a/src/dxvk/dxvk_instance.cpp b/src/dxvk/dxvk_instance.cpp
index 8af4a0512..262bef631 100644
--- a/src/dxvk/dxvk_instance.cpp
+++ b/src/dxvk/dxvk_instance.cpp
@@ -154,8 +154,6 @@ namespace dxvk {
   
   
   std::vector<Rc<DxvkAdapter>> DxvkInstance::queryAdapters() {
-    DxvkDeviceFilter filter;
-    
     uint32_t numAdapters = 0;
     if (m_vki->vkEnumeratePhysicalDevices(m_vki->instance(), &numAdapters, nullptr) != VK_SUCCESS)
       throw DxvkError("DxvkInstance::enumAdapters: Failed to enumerate adapters");
@@ -163,15 +161,22 @@ namespace dxvk {
     std::vector<VkPhysicalDevice> adapters(numAdapters);
     if (m_vki->vkEnumeratePhysicalDevices(m_vki->instance(), &numAdapters, adapters.data()) != VK_SUCCESS)
       throw DxvkError("DxvkInstance::enumAdapters: Failed to enumerate adapters");
-    
-    std::vector<Rc<DxvkAdapter>> result;
+
+    std::vector<VkPhysicalDeviceProperties> deviceProperties(numAdapters);
+    DxvkDeviceFilterFlags filterFlags = 0;
+
     for (uint32_t i = 0; i < numAdapters; i++) {
-      VkPhysicalDeviceProperties deviceProperties;
-      m_vki->vkGetPhysicalDeviceProperties(adapters[i], &deviceProperties);
+      m_vki->vkGetPhysicalDeviceProperties(adapters[i], &deviceProperties[i]);
 
-      if (deviceProperties.apiVersion < VK_MAKE_VERSION(1, 1, 0))
-        Logger::warn(str::format("Skipping Vulkan 1.0 adapter: ", deviceProperties.deviceName));
-      else if (filter.testAdapter(deviceProperties))
+      if (deviceProperties[i].deviceType != VK_PHYSICAL_DEVICE_TYPE_CPU)
+        filterFlags.set(DxvkDeviceFilterFlag::SkipCpuDevices);
+    }
+
+    DxvkDeviceFilter filter(filterFlags);
+    std::vector<Rc<DxvkAdapter>> result;
+
+    for (uint32_t i = 0; i < numAdapters; i++) {
+      if (filter.testAdapter(deviceProperties[i]))
         result.push_back(new DxvkAdapter(m_vki, adapters[i]));
     }
     
